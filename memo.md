### git の仕組み

git はスナップショットを記録している。

バージョン 1:ファイル A、B、C

バージョン 2:ファイル A、B1、C1

バージョン 3:ファイル A1、B1、C2

バージョン 2 を保存する時、ファイル B1、C1 はファイル B、C との差分ではなく、
ファイル B1、C1 を丸ごと保存する。
バージョン 3 を保存する時、ファイル A1、C2 はファイル A、C1 との差分ではなく、ファイル A1、C2 を丸ごと保存する。

スナップショットとして保存することで複数人での開発(ブランチを切ったりマージする時)をスピードアップさせることができる。

### バージョン記録によってできる事

バージョン記録の際、git はコミットを行う。
それぞれのコミット は直前のコミットとして保存している為、コミットをたどることで、以前の状態に戻すことができる。

### 作業の流れ

ローカル(自分の PC)のワークツリー上での変更のスナップショットを記録して、ローカルレポジトリに保存。
ローカルレポジトリから、GitHub(リモートレポジトリ) にアップする。

ワークツリー：作業ディレクトリやフォルダ
レポジトリ：履歴データの保管場所(データベース)

リモート：自分の PC とは異なる場所、を指す。

逆に、他人の変更をローカルに取り込む場合の作業の流れは、
GitHub(リモートレポジトリ)から変更内容をローカルレポジトリに取得し、
その後、ワークツリーに内容を反映させる。

### ローカルの 3 つのエリアについて

ローカルは、ワークツリー、ステージ、(ローカル)レポジトリの 3 つのエリアに分かれている。
ワークツリー：同上
ステージ：コミットする変更を準備する場所。

> git add .

※ステージが存在する理由
全ての変更が完了していなくても途中で GitHub にアップしたい、といった場合に、
ステージに反映させたファイルだけをレポジトリにスナップショットとして記録する為。

レポジトリ：ステージに追加されたファイルをスナップショットとして記録する為の場所。

> git commit -m "..."

### Git でのデータ構造

git add を実行する際、まずワークツリー上の index.html というファイルの圧縮ファイル A がレポジトリに保存する。
その後、ステージ上に index.html と、圧縮ファイル A を紐づけるインデックス情報を保存する。

git commit を実行する際、ステージ上のインデックス情報のファイル構成を元に、ツリー情報 1 がレポジトリに作成する。
その後、

> ツリー情報 1、作成者、日付、コミットメッセージ

をひとまとめにしたコミット情報 1 をレポジトリに作成する。

git add、git commit が完了した時点で、ローカルレポジトリには圧縮ファイル A,ツリー情報 1、コミット情報 1 の 3 つのデータが保存されている。

この状態から、新たに home.css というファイルをコミットする場合、
まず、git add で圧縮ファイル B をレポジトリに追加し、ステージのインデックスに home.css と圧縮ファイル B を紐づけたインデックス情報が追加される。

git commit によって、インデックス情報を元に新たにツリー情報 2 がレポジトリに追加される。そして、

> ツリー情報 2、親コミット情報、作成者、日付、コミットメッセージ

をひとまとめにしたコミット情報 2 をレポジトリに作成する。

コミットに直前のコミット情報を保持しておくことで、変更分をたどれるようにしておく。

git add でインデックス作成、git commit でツリー作成が分かれている理由
→ インデックス作成をする度に、インデックスは上書きされるが、ツリーは別ファイルとして保存されることから、データの管理が非効率的になる為。

### 圧縮ファイルについての詳細

圧縮ファイルはレポジトリに追加したいファイルの中身そのものを圧縮したもので、正確には「blob（ブロブ）オブジェクト」と言う。

圧縮ファイルのファイル名はハッシュ ID になる。

ハッシュ ID：ヘッダー（ファイル内容の文字数など、ファイルのメタ情報）とファイル内容を、SHA-1 というハッシュ関数で 40 文字の英数字に変換したもの。ハッシュ ID のうち、先頭 2 文字をディレクトリ名に、残り 38 文字をファイル名にして保存する。

> git hash-object memo.md

> git add memo.md

> tree .git
